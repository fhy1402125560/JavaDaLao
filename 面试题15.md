# 1.http和https的区别

**端口号**：HTTP 默认是 80，HTTPS 默认是 443。

**URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

**安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

**SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

# 2.面向对象的特征

**封装：** 封装就是吧一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但可以提供一些可以被外界访问的方法			 来操作属性

**继承：** 子类拥有父类对象所有的属性和方法，但是父类中的私有属性和方法子类无法访问，只是拥有  
			 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
			 子类可以用自己的方式实现父类的方法，也就是重写

**多态：** 父类的引用指向子类的实例
			 对象类型和引用类型之间具有继承或实现的关系
			 多态不能调用旨在子类不在父类中的方法
			 如果子类重写了父类的方法，执行的是子类的方法，没重写执行的是父类的方法			

# 3.synchronized ReentrantLock区别

**1. 锁的实现**

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

**2. 性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**3. 等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。

**4. 公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

**5. 锁绑定多个条件**

一个 ReentrantLock 可以同时绑定多个 Condition 对象。

### 使用选择

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

# 4.synchronized用在成员方法和静态方法上有什么不同             

成员方法上是 **当前对象实例的锁**

静态方法是 **对当前的类上锁**

# 5.MySQL隔离级别

READ-UNCOMMITTED读未提交 ：最低的隔离级别，允许读取未提交的数据变更，可能会导致脏读、幻读、不可重复读

READ-COMMITTED读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，可能导致幻读、不可重复读

REPEATABLE-READ可重复读：对同一字段的多次读取结果都是一致的，除非数据被本身事务自己所修改，可以阻止脏读和不可重复读，但可能导致幻读

SERIALIZABLE可串行化：最高的隔离级别，完全服从ACID，可以防止脏读、不可重复读、幻读

# 6.JVM 中一次完整的 GC 流程是怎样的

Eden-->survivor-->老年代

GC机制发生在堆内存中，Java堆=新生代+老年代，新生代=Eden+s0+s1

当Eden区的空间满了，Java虚拟机回触发一次MinorGC，回收新生代的垃圾，存活的对象回转移到Survivor区

**大对象**(需要大量连续内存空间的Java对象，如长字符串)，直接进入老年代

对象在Eden出生，经过一次MinorGC后存活，并被Survivor容纳，年龄设为1，没经过一次MinorGC，年龄+1，**年龄超过15 ，晋升至老年代**。**即长期存活的对象进入老年代**

老年代满了无法容纳更多的对象，MinorGC之后回进行FullGC，FullGC清理整个堆内存，包括新生代和老年代

MajorGC发生在老年代，清理老年区，比MinorGC慢10倍以上



新生代采用的是复制算法，因为新生代中每次都会回收大量对象，存活下来的较少。新生代一共被分成了三块，Eden和两个survivor，对象在Eden区出生，当进行回收时，讲Eden区和一块survivor区的存活的对象复制到另一块survivor

老年代回收少量对象，因此待用**标记整理法**(Mark-Compact)。

# 7.为什么G1从JDK 9之后成为默认的垃圾回收器

**并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。
**分代收集**：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过15次GC的旧对象以获取更好的收集效果。
**空间整合**：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。
**可预测的停顿**：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。尤其大内存的堆空间效果要高于其他。