# 1.**Redis 的过期策略是怎么样的？** 

Redis通过一个叫做过期字典开保存数据过期的时间。过期字典的键值指向Redis中的某个key，过期字典的值是一个long类型的整数，这个整数保存了key的过期时间

Redis的过期策略是 定期删除和惰性删除

**惰性删除**是只会在取出key的时候对数据进行过期检查

**定期删除**就是Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期，过期就删除

定期删除对内存更好，惰性删除对CPU更友好，所以Redis采用的是定期删除+惰性删除两种过期策略

不过定期删除和惰性删除还存在问题，有可能漏掉很多过期的key堆积在内存中，然后就OOM了

想解决这个问题，可以走 **Redis内存淘汰机制**

# 2.**Redis的内存淘汰策略是怎么样的？**

- no-eviction: 内存不足时禁止写入新数据
- allkeys-lru: 内存不足时，在key空间中，移除最近最少使用的key(最常用)
- allkeys-random: 内存不足时，随机移除某个key
-  volatile-lru:内存不足时，在已设置过期时间的key中，移除最近最少使用的key
- volatile-random: 内存不足时，在设置过期时间的key中随机移除某个key
- volatile-ttl: 内存不足时，在已设置过期时间的key中移除将要过期的key

4.0版本后新增加了两种

- allkeys-lfu: 内存不足时，移除最不经常使用的key
- volatile-lfu: 内存不足时，在已设置过期时间的key中，移除最不经常用的key

# 3.**什么是缓存击穿、缓存穿透、缓存雪崩 解决办法？**

- **缓存穿透**: 就是数据库和缓存中都不存在大量请求的key，就导致这些不存在的key的请求直接到了数据库，数据库就容易挂掉

  **解决方案：**每次请求在数据库中只要没查到，就在缓存中写一个空值，比如`set -999 UNKNOWN`,然后设置一个过期时间

- **缓存击穿**：就是请求的key是热点数据，访问频繁，在高并发的情况下，当这个key失效的瞬间，大量的请求就击穿了缓存，直接访问数据库

  **解决方案**: 

  ​	1.  若缓存中的数据基本上不会发生更新，则可以设置热点数据永不过期或过期时间较长

  				  2.  若缓存中的数据更新不频繁，且缓存刷新的整个流程耗时比较少的情况下，则可以采用Redis、Zookeeper等分布式中间件的分布式互斥锁，保证只会有一个请求落在数据库上
  				  2.   针对热点数据提前预热， 设置合理的过期时间

- **缓存雪崩**: 缓存在同一时间大面积失效，导致大量请求落在数据库上

  **解决方案**: 

  ​				事前：Redis高可用，主从+哨兵，Redis Cluster，避免全盘崩溃

  ​				事中： 本地cache缓存+hystrix限流&降级(Sentinel限流降级),bimian MySQL崩溃

  ​				事后：Redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据



# 4.**什么情况下会出现数据库和缓存不一致的问题？** 

当某个值被缓存起来时，在数据库发生了更改，但是缓存中的值没有被更新，导致缓存中的数据与数据库的数据不同步问题

# 5.**如何解决Redis和数据库的一致性问题？** 

1. 想要提高应用的性能，可以引入「缓存」来解决
2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」
3. 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生
4. 在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案
5. 在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性
6. 在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率



# 6.**Redis如何实现延迟消息？** 

延时队列可以通过zset实现，因为zset中有一个score，我们可以把事件作为score，将value存到redis中，然后通过轮询的方式，区不断地读取消息出来

1. 消息题设置有效期，设置好score，然后放入zset中
2. 通过排名拉取消息
3. 有效期到了，就把消息从zset中移除

# 7.**介绍下Redis集群的脑裂问题？**

Redis脑裂问题是因为网络问题

Redis集群中，哨兵会每隔一段时间就ping一下看看master是否健在，如果master挂了，哨兵就会再slave中选举一个服务器做master

选举完成后slave变成了master,这时原来的master重启了，此时存在两个master,

客户端还在向原来的master继续写入数据，那么新的master无法同步这些数据，网络问题解决后，哨兵会将原来的master降为slave,此时无法再从新的master中同步数据，将会造成大量的数据丢失

**解决方案**

redis配置文件中存在两个参数

`min-slaves-to-write 3`  连接到master的最少slave数量

`min-slaves-max-lag 10`  slave连接到master的最大延迟事件

至少3个slave节点，且数据复制和同步的延迟不能超过10秒，否则的话master就会拒绝写请求，配置了这两个参数之后，如果发生集群脑裂，原先的master节点接收到客户端的写入请求会拒绝，就可以减少数据同步之后的数据丢失。

较新版本的redis.conf文件中的参数变成了

```text
min-replicas-to-write 3
min-replicas-max-lag 10
```

