# 1.**什么是Nacos，主要用来作什么 应用流程 和常用注解？**

 Nacos是SpringCloudAlibaba里的一个分布式中间件，主要用于服务注册、服务发现，配置管理和服务治理

1. `@EnableNacos`：该注解用于启用 Nacos 的服务发现功能。在服务的启动类上添加该注解，将自动注册服务到 Nacos 服务器。
2. `@NacosService`：该注解用于标记一个服务类，以便 Nacos 可以自动发现并注册该服务。在服务类上添加该注解，并指定服务的名称和分组。
3. `@NacosConfig`：该注解用于标记一个配置类，以便 Nacos 可以自动加载并管理该配置。在配置类上添加该注解，并指定配置的名称和分组。
4. `@NacosProperty`：该注解用于标记一个配置项，以便 Nacos 可以自动加载并管理该配置项。在配置类的属性上添加该注解，并指定配置项的名称和默认值。

​	

# 2.**什么是QPS，什么是RT？** 

QPS是每秒查询率，用于评估数据库、网络、服务器等系统的处理能力

RT是响应时间，指请求发送到接收到请求的时间间隔

# 3.**如何设计一个能够支持高并发的系统？** 

从6个方面来说

1. 系统拆分：将一个系统拆分成多个子系统，可以用dubbo来搞，然后每一个系统连一个数据库，单个数据库扛不住，多整几个就行了
2. 缓存：高并发场景都是读多写少，在缓存和数据库中都存一份，然后读的时候走缓存
3. MQ：项目中也可能出现高并发写的问题，比如说一个业务系统频繁高数据库几十次，增删改增删改，数据库就挂了。用redis肯定不行，数据随时就LRU了，还没有事务支持。所以还得用MySQl，引入MQ，大量请求写MQ里，排队后慢慢消费，后面系统消费后慢慢写
4. 分库分表：可能到最后数据库层面还是扛不住高并发的要求，那就将一个数据库拆分成多个库；然后将一个表拆分为多个表，每个表的数据量少一点，提升sql的性能
5. 读写分离：大多数数据库还是读多写少，没必要所有请求都集中在一个库上，可以搞个主从架构，主库写入，从库读取，搞一个读写分离
6. ES：分布式搜索，数据库的全文检索比较慢，用es搜索快

# 4.**什么是服务降级？降级的方式** 

降级是从系统功能优先级的角度考虑如何应对系统故障

方式：

拒绝请求

延时响应

降低服务质量

关闭非核心功能

进行数据备份

# 5.**什么是熔断？为什么需要熔断** 

熔断是应对微服务雪崩效应的一种链路保护机制

当某服务出现不可⽤或响应超时的情况 时，为了防⽌整个系统出现雪崩，暂时停⽌对该服务的调⽤。

# 6.**什么是预热？它有何作用？** 

缓存预热是一种在应用程序驱动或缓存失效之后，主动将热点数据加载到缓存中的策略，提高了缓存命中率

缓存预热可以避免用户请求的时候先查询数据库，然后再缓存数据的问题，用户直接访问实现被预热的缓存数据

# 7.**什么是限流？常见的限流算法有哪些？** 

限流是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。

限流可能会导致用户的请求无法被正确处理或者无法被立即处理、

1. 固定窗口计数器算法
2. 滑动窗口计数器算法
3. 漏桶算法
4. 令牌桶算法

可以针对IP、业务ID、个性化(例如VIP用户不限流，普通用户限流)

# 8.**Sentinel和Hystrix有什么区别？** 

|                | Sentinel                         | Hystrix               |
| -------------- | -------------------------------- | --------------------- |
| 隔离策略       | 信号量隔离(并发控制)             | 线程池隔离/信号量隔离 |
| 降级策略       | 基于慢调用比例、异常比例、异常数 | 基于异常比例          |
| 扩展性         | 多个扩展点                       | 插件的形式            |
| 注解支持       | 支持                             | 支持                  |
| 限流           | 基于QPS                          | 有限的支持            |
| 流量整形       | 支持预热模式与匀速排队控制效果   | 不支持                |
| 系统自适应保护 | 支持                             | 不支持                |
| 多语言支持     | Java/Go/C++                      | Java                  |
| 控制台         | 可配置规则、实时监控、机器发现等 | 简单的监控查看        |



# 9.布隆过滤器原理

布隆过滤器（Bloom Filter）是一种空间效率很高的概率数据结构，它利用多个哈希函数将一个元素映射到一个位数组中，以确定该元素是否在集合中。 布隆过滤器的原理如下：



- 当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。
- 检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。



布隆过滤器的误判率与哈希函数的个数、位数组的长度有关，误判率越低，则数组越长，所占空间越大。 因此，在使用布隆过滤器时，需要根据实际情况选择合适的哈希函数个数和位数组长度，以平衡误判率和空间效率。