## 1.事务有什么特性？

ACID

### 2.TCP/IP 五层协议哪五层？

1、物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。
2、数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。
3、网络层：负责地址管理和路由选择。路由器工作在网络层。
4、传输层：负责两台主机之间的数据传输。
5、应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。



**应用层**：HTTP(超文本传输协议), HTTPS(更安全的超文本传输协议), FTP(文件传输协议), SMTP(简单邮件传输协议), DNS(域名服务)，ping命令（调试网络环境），OSPF(开放最短路径优先)；

应用层处理应用程序的逻辑，且应用层在用户空间。

**传输层**：UDP(用户数据报协议), TCP(传输控制协议)；

传输层采用端到端的通信方式，其中：

UDP：不可靠的，无连接的，基于数据报的协议；

TCP：可靠的，面向连接的，基于字节流的协议；

**网络层**：IP(因特网协议), ICMP(控制报文协议), ARP(地址解析协议), RARP(反向地址转换协议)；

网络层主要实现数据包的选路和转发。



**数据链路层**：传输单位是帧，分为逻辑链路控制子层（LLC），媒体访问控制子层（MAC）；

数据链路层是网卡接口的驱动程序，处理数据在物理媒介的传输

**物理层**：传输单位是比特流

​             传输的主要介质：集线器、中继器、调制解调器、网线、双绞线、同轴电缆。

## 3.TCP和UDP有哪些区别 

**是否面向连接**：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。

**是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。

**是否有状态**：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。

**传输效率**：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。

**传输形式**：TCP 是面向字节流的，UDP 是面向报文的。

**首部开销**：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。

**是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；

**UDP 一般用于即时通信**，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。

**TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

## 4.线程的实现方式有哪些？

1. 继承Thread
2. 实现Runnable
3. 实现Callable
4. 线程池

## 5.http和https的区别

**端口号**：HTTP 默认是 80，HTTPS 默认是 443。

**URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

**安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

**SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

## 6.服务熔断和服务降级

降级的⽬的在于应对系统⾃身的故障，⽽熔断的⽬的在于应对当前系统依赖的外部系统或者第三⽅系统的故障。

熔断是应对微服务雪崩效应的⼀种链路保护机制，类似股市、保险丝
微服务之间的数据交互是通过远程调⽤来完成的。服务 A 调⽤服务 B，服务 B 调⽤服
务 C，某⼀时间链路上对服务 C 的调⽤响应时间过⻓或者服务 C 不可⽤，随着时间的
增⻓，对服务 C 的调⽤也越来越多，然后服务 C 崩溃了，但是链路调⽤还在，对服务
B 的调⽤也在持续增多，然后服务 B 崩溃，随之 A 也崩溃，导致雪崩效应
服务熔断是应对雪崩效应的⼀种微服务链路保护机制。例如在⾼压电路中，如果某个
地⽅的电压过⾼，熔断器就会熔断，对电路进⾏保护。同样，在微服务架构中，熔断
机制也是起着类似的作⽤。当调⽤链路的某个微服务不可⽤或者响应时间太⻓时，会
进⾏服务熔断，不再有该节点微服务的调⽤，快速返回错误的响应信息。当检测到该
节点微服务调⽤响应正常后，恢复调⽤链路。
服务熔断的作⽤类似于我们家⽤的保险丝，当某服务出现不可⽤或响应超时的情况
时，为了防⽌整个系统出现雪崩，暂时停⽌对该服务的调⽤。
熔断

降级是从系统功能优先级的⻆度考虑如何应对系统故障。
服务降级指的是当服务器压⼒剧增的情况下，根据当前业务情况及流量对⼀些服务和
⻚⾯有策略的降级，以此释放服务器资源以保证核⼼任务的正常运⾏。

## 7.说一下SpringCloud

- SpringCloud是一系列框架的集合，基于SpringBoot，简化了分布式系统基础设施的开发，如服务发现注册、配置中心、网关路由、消息总线、负载均衡、断路器、数据监控等的微服务架构
- Spring Cloud Eureka：服务注册与发现
  Spring Cloud Zuul：服务网关
  Spring Cloud Ribbon：客户端负载均衡
  Spring Cloud Feign：声明性的Web服务客户端
  Spring Cloud Hystrix：断路器
  Spring Cloud Config：分布式统一配置管理

## 8.反射，使用反射的好处是什么

通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法

Spring/SpringBoot、Mybatis等框架中运用了大量的反射机制

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的

## 9.spring常用的注解，注解中用到了什么设计模式

@Configuration 用来标记类可以当做一个bean的定义，被Spring IOC容器使用

@Bean 表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文

@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的
组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。
@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IOC 容
器中。
@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以
在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。
@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了
额外的好处。它将 DAO 导入 IOC 容器，并使未经检查的异常有资格转换为 SpringDataAccessException。

@Required：bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动
装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException

@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它
required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自
动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多
个参数的PN方法。

@Qualifier：创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义

@RequestMapping： 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/
方法。此注释可应用于两个级别：
类级别：映射请求的 URL
方法级别：映射 URL 以及 HTTP 请求方法



1. 工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；
2. 单例模式：Bean默认为单例模式。
3. 代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；
4. 模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
5. 观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的
对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。

## 10.为什么握手三次断开要四次

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

1. **第一次握手**：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
2. **第二次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
3. **第三次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后。

1. **第一次挥手**：A 说“我没啥要说的了”
2. **第二次挥手**：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
3. **第三次挥手**：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
4. **第四次挥手**：A 回答“知道了”，这样通话才算结束。

