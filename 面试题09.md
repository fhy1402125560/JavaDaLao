### 1.死锁产生的必要条件

- 互斥条件：在一段时间内某资源只由一个就能成占用。如果此时还有其他进程请求资源，就只能等待，直至占有资源的进程用完释放
- 占有且等待条件：值进程已经保持至少一个资源。但又提出了新的资源请求，而该资源已被其他资源占有，此时进程堵塞，但又对自己已获得的其他资源保持不放
- 不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢来
- 循环等待条件：若干进程之间形成一种头尾详解的循环等待资源(比如一个进程集合，A在等B，B在等C，C在等A)

### 2.了解哪些设计模式，单列模式有哪几种实现方式

- 创建式模型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构式模型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

实现方式

1. 饿汉式：类初始化时，会立即加载该对象，线程天生安全，调用效率高
2. 懒汉式：类初始化时，不会初始化该对象，真正需要使用时才会创建该对象，具备懒加载功能
3. 静态内部方式：结合了懒汉式和饿汉式各自的优点，真正需要对象时才会加载，加载类时线程安全的
4. 枚举单例：使用枚举实现单例模式。优点：实现简单，调用效率高，枚举本身就是单例，由JVM从根本上提供保障，避免通过反射和反序列化的漏洞，缺点没有延迟加载
5. 双重检测锁方式(因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)

### 3.分布式锁的实现方式有哪些

- 基于关系型数据库比如MySQL实现分布式锁，通过唯一索引或排他锁实现，不过一般不会使用，问题太多比如性能太差、不具备锁失效机制
- 基于分布式协调服务Zookeeper实现分布式锁
- 基于分布式键值存储系统比如Redis、Etcd实现分布式锁

### 4.Redis数据结构类型，除了能做缓存还能做什么？

Hash、List、String、Set、Zset、Bitmap、HyperLogLog

计数器、缓存、会话缓存、全页缓存(FPC)、查找表、分布式锁、限流、消息队列、延时队列、分布式Session、复杂业务场景

### 5.redis内部原理，一个key在怎么确定在redis集群的哪个节点上

1. Redis支持多种数据结构，每种数据结构都有自己的内部表示和操作。
2. Redis是一个基于内存的数据库系统，所有数据都存储在内存中。使用了内存回收机制，包括键的过期策略和内存淘汰策略，确保系统的稳定性和性能
3. Redis支持持久化机制，RDB、AOF和ROBAOF混合机制
4. Redis使用单线程模型处理所有的客户端请求。这意味着Redis同一时刻只能处理一个请求，但他通过时间驱动和非阻塞I/O实现高并发。
5. Redis支持主从复制机制，可以将一个Redis服务器的数据复制到多个服务器上。



在Redis集群中，确定一个key存储在哪个节点上是通过哈希槽实现的。Redis使用哈希槽将所有的key划分到不同的槽位中，然后将这些槽位分布在集群的各个节点上。这个过程使用一种叫做CRC16算法的哈希函数来实现

### 6.AOF与RDB持久化方式的区别

RDB是按照一定时间将内存中的数据以快照的形式保存到硬盘中，会生成一个dump.rdb文件。Redis默认使用RDB持久化。Redis提供了两个命令生成RDB快照文件。save同步保存操作，会阻塞主线程，bgsave会fork出一个子进程，子进程执行，不会阻塞主线程，默认使用。在每次关闭Redis时也会自动触发RDB。

AOF持久化是将Redis每次执行的写命令记录到appendonly.aof文件中，当重启Redis会从.aof文件中恢复数据。当RDB和AOF同时开启时会优先选择AOF恢复。在Redis配置文件中有三种AOF持久化方式，appendfsync always：主线程调用write执行写操作后，后台线程调用fsync函数同步AOF文件；appendfsync everysec：主线程调用write执行写操作后,每秒调用一次fsync同步一次AOF文件；appendfsync no：主线程调用write执行写操作后立即返回，让操作系统决定何时同步。

### 7.B+树数据结构讲一下？

B+树是有B树演化而来，是平衡多路查找树，每个节点有多个子节点，叶子节点之间通过有序链表连接。B+树的索引存放在内部节点中，数据存储在叶子节点中，这里和B树是不一样的，B树的内部节点和叶子节点都存放索引和数据。

