### 1.Redis的持久化机制，过期策略有哪些，删除机制

Redis持久化机制有RDB、AOF和Reids4.0新增的RDB和AOF的混合持久化。

RDB是按照一定时间将内存中的数据以快照的形式保存到硬盘中，会生成一个dump.rdb文件。Redis默认使用RDB持久化。Redis提供了两个命令生成RDB快照文件。save同步保存操作，会阻塞主线程，bgsave会fork出一个子进程，子进程执行，不会阻塞主线程，默认使用。在每次关闭Redis时也会自动触发RDB。

AOF持久化是将Redis每次执行的写命令记录到appendonly.aof文件中，当重启Redis会从.aof文件中恢复数据。当RDB和AOF同时开启时会优先选择AOF恢复。在Redis配置文件中有三种AOF持久化方式，appendfsync always：主线程调用write执行写操作后，后台线程调用fsync函数同步AOF文件；appendfsync everysec：主线程调用write执行写操作后,每秒调用一次fsync同步一次AOF文件；appendfsync no：主线程调用write执行写操作后立即返回，让操作系统决定何时同步。

Redis时关系型数据库，可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。

过期策略通常有三种：

- 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。定时过期可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量
- 惰性过期：只有当访问一个key时，才会判断该key是否过期，过期则删除。惰性过期可以最大化的节省CPU资源，但对内存不友好。极端情况下可能出现大量的过期key没有被再次访问，从而不会被清除，占用大量内存
- 定期过期：每隔一段时间，会扫描一定数据量的数据库expires字典中一定数量的key，并清除已过期的key。定期过期是一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

Redis中同时使用了惰性过期和定期过期两种过期策略

**`相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?`**

Redis提供了6种数据淘汰策略

1. volatile-lru(Least recently used，最近最少使用)：从已设置过期时间的数据集种挑选最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的)
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-evivtion：禁止驱逐数据，也就是说当内存不足以容纳新数据写入新数据时，新写入操作会报错。

4.0版本后添加了两种：

7. volatile-lfu(Least Frequently Used)最不经常使用：从已设置过期时间的数据集中挑选最不常使用的数据淘汰
8. allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

### 2.乐观锁和悲观锁及使用场景

悲观锁：总是假象最坏的情况，每次去拿数据的时候都认为别人会修改，所以在每次拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据里面就用到了很多悲观锁，比如行级锁、表级锁、读锁、写锁等，都是在做操作之前先上锁。Java里的synchronized关键字的实现也是悲观锁

乐观锁：总是假象最好的情况，每次去拿数据的时候都认为别人不会修改 ，所以不会上锁，但是在更新的时候会判断一下在此期间有没有别人去更新这个数据，可以用版本号机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。想数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中的Atomic原子类就是用乐观锁的一种实现方式CAS实现的

### 3.hashmap和hashtable的区别

线程：HashMap线程不安全，HashTable线程安全，因为HashTable内部的方法基本都用synchronized修饰。不过HashTable已经淘汰，要保证线程安全用ConcurrentHashMap

效率：因为线程安全的问题，HashMap比HashTable效率高一点。

对Null Key和Null Vaule的支持：HashMap可以存储null的key和vaule，但null键只能有一个，null值可以有多个。HashTable不允许有null键和null值，否则会抛出NullPointerException

初始容量大小和每次扩容大小不同：	

1.  创建时不指定容量初始值，HashTable默认的初始大小为11，每次扩容，容量变为原来的2n+1.HashMap默认初始化大小为16，每次扩容，容量变为原来的2倍
2. 创建时给定了初始值，HashTable会直接使用给定的大小，HashMap会将其扩容为2的幂次方大小(HashMap中的tableSizeFor()方法保证)

底层数据结构：JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，会将链表转化为红黑树(将链表转化为红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转化红黑树)，以减少搜索时间。HashTable没有这样的机制。

### 4.redis缓存穿透

Redis缓存穿透就是用户透过Redis去请求MySQL服务器，导致MySQL压力过载。

解决办法：

1. 如果缓存和数据库都查不到某个key的数据，这时可以将key-value改写为key-null，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击

   ```java
   public Object getObjectInclNullById(Integer id) {
       // 从缓存中获取数据
       Object cacheValue = cache.get(id);
       // 缓存为空
       if (cacheValue == null) {
           // 从数据库中获取
           Object storageValue = storage.get(key);
           // 缓存空对象
           cache.set(key, storageValue);
           // 如果存储数据为空，需要设置一个过期时间(300秒)
           if (storageValue == null) {
               // 必须设置过期时间，否则有被攻击的风险
               cache.expire(key, 60 * 5);
           }
           return storageValue;
       }
       return cacheValue;
   }
   
   ```

   

2. 采用布隆过滤器，把所有可能存在的数据哈希到布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

### 5.分布式锁的实现，和各自的优缺点

- 基于关系型数据库比如 MySQL 实现分布式锁。
- 基于分布式协调服务 ZooKeeper 实现分布式锁。
- 基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。

关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。

通常情况下会选择基于Redis或Zookeeper实现分布式锁，Redis用的多一点。

在Redis中，`SETNX`命令可以实现互斥。`SETNX`即SET if Not eXists(对应Java中的setIfAbsent()方法)，如果key不存在的话，才会设置key的值。如果key已经存在，`SETNX`什么都不做。

```sh
> SETNX lockKey uniqueValue
(integer) 1
> SETNX lockKey uniqueValue
(integer) 0
```

释放锁直接通过`DEL`命令删除对应的key即可

```sh
> DEL lockKey
(integer) 1
```

ZooKeeper 分布式锁是基于 **临时顺序节点** 和 **Watcher（事件监听器）** 实现的。

获取锁：

1. 首先我们要有一个持久节点`/locks`，客户端获取锁就是在`locks`下创建临时顺序节点。
2. 假设客户端 1 创建了`/locks/lock1`节点，创建成功之后，会判断 `lock1`是否是 `/locks` 下最小的子节点。
3. 如果 `lock1`是最小的子节点，则获取锁成功。否则，获取锁失败。
4. 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如`/locks/lock0`上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。

释放锁：

1. 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。
2. 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。
3. 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。

### 6.redis 数据结构

Redis有5种基础数据类型和3种特殊数据类型和一些其他的数据类型。

- 5种基础数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）
- 3种特殊数据类型：HyperLogLog（基数统计）、Bitmap（位图）、Geospatial（地理位置）
- 其他：Bloom fileter（布隆过滤器）、Bitfield（位域）

### 7.Redis为什么被设计成是单线程的

不需要各种锁的性能消耗

Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。

总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗。

单线程多进程集群方案

单线程的威力实际上非常强大，单核cpu效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。

所以“单线程、多进程的集群”不失为一个时髦的解决方案。

CPU消耗

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。

但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？

可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。