### 1.事务的特性，分别是什么 怎么保证

​	事务(Transaction)是数据库管理系统的一个概念，用于确保数据的一致性和完整性。事务有四个主要特性，通常被称为ACID特性，分别是

1. 原子性(Atomicity): 事务不可分割的操作单元，要么全部执行成功，要么全部失败。如果事务中任何一部分操作失败，整个事务都应该被回滚，恢复到事务开始前的状态，以确保数据库的一致性。
2. 一致性(Consistency): 确保事务在执行前和执行后，数据库的完整性约束没有被破坏。换句话说，事务应该将数据库从一个一致性状态转移到另一个一致性状态，而不会破坏数据的完整性
3. 隔离性(Isolation): 在多个事务同时执行时，每个事务应该被隔离开来，互不干扰。这可以通过锁定机制来完成，以确保一个事务的修改在另一个事务看来是不可见的，直到第一个事务完成
4. 持久性(Durability): 确保事务一旦提交，其对数据库的修改应该是永久性的，即使系统崩溃或重启，事务的结果也不应该丢失

要保证这些事务特性，数据库管理通常使用日志记录、锁定机制和回滚机制等技术。日志记录用于追踪事务的操作，以便在系统故障时进行恢复。锁定机制用于管理并发访问数据库的事务，以确保隔离性。回滚机制用于撤销未完成的事务或者在事务失败时回滚已经提交的事务，以保证原子性和一致性

### 2.介绍一下equals()方法和hashcode()方法

​	equals()方法用来比较两个对象是否相等，但分为两种情况。

1. 没重写equals()方法的时候，比较的是两个对象在内存中的地址值是否相同
2. 重写equals()方法，比较的是两个对象的内容是否相同

​	hashcode()方法的作用是获取哈希值，返回的是一个int类型的整数，哈希值的作用是确定该对象在哈希表中的索引位置。

通常情况下需要同时重写hashcode()方法和equals()方法

同时重写hashcode()方法和equals()的原因是确保对象在以哈希表为底层原理的集合中能够正确比较和存储。如果两个对象通过equals()方法比较相等之后具有不同的哈希值，这两个对象可能会被存储在不同的位置，从而导致无法正确查找对象，重写hashcode()方法可以确保相同的对象具有相同的哈希值。



### 3.如何调用反射获取private修饰的成员变量

​	获取类的Class对象，可以用Class.forName("ClassName")方法，也可以使用getClass()方法获取

​	获取私有成员变量的Field对象，使用getDeclaredFiled("FieldName")方法获取

​	设置Field对象可访问，setAccessible(true)

​	获取成员变量的值，使用Field对象.get(Object obj)方法获取

### 4.springboot比spring优势

​	Spring需要配置文件，Springboot不需要配置文件

​	Springboot内嵌了多种服务器，如Tomcat Jerry Undertow等，无需手动部署

​	Springboot使用了Starter依赖项，添加之后Springboot自动处理依赖和版本冲突

​	Springboot可以用来构建微服务

​	Springboot自动扫面路径上的文件，自动配置SpringBean

​	Springboot可以实现热部署

​	

### 5.过滤器和拦截器的区别和使用场景

​	过滤器(Filter)和拦截器(Interceptor)是在Web应用中处理请求和响应的组件，

​	过滤器是在Servlet容器中执行的，在请求到达Servlet之前和响应返回客户端之前起作用。拦截器是在SpringMVC中执行的，通常在请求进入控制器方法和离开控制器之后起作用。

​	过滤器主要用于通用的请求和响应处理，例如日志记录、字符编码转换、身份验证、IP过滤和黑名单等。拦截器主要用于处理Web框架中的控制层逻辑和业务相关的功能，例如身份验证、权限检查、事务管理、异常处理等。通常与特定的控制器或控制器方法关联，更精细的控制请求和响应。

### 6.类加载机制

​	类加载机制就是把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的java类型。

![2205975703-5f9236b4c9ec1_fix732](C:\Users\ASUS\Desktop\2205975703-5f9236b4c9ec1_fix732.webp)

1. 加载

   - 通过类的全路径名(包名+类名)，获取到该类的.class文件的二进制字节流
   - 将二进制字节流所代表的静态存储结构，转化为方法区运行时数据结构
   - 在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的而各种数据的访问入口
   - 加载二进制数据到内存-->映射成jvm能识别的结构-->在内存中生成class文件

2. 链接

   链接是值将加载创建的class对象合并至Java虚拟机中，使之能够执行的过程，分为验证、准备、解析三个阶段

   - 验证  

     确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全

   - 准备

     为类中的**静态字段**分配内存，并设置默认的初始值，比如int类型的初始值为0.被final修饰的static字段不会设置，因为final在编译时就分配了

   - 解析

     在解析阶段，虚拟机会把这个Class文件中，常量池的符号引用转换为直接引用。主要解析的是 类、接口、字段、类方法、接口方法、方法类型、方法句柄等符号引用。可以把解析阶段中，符号引用转换为直接引用的过程，理解为当前加载的这个类，和它所引用的类，**正式进行“连接”的过程**

3. 初始化

   - 初始化就是执行 类的构造器方法init() 的过程

     init()方法不需要定义，是javac编译器自动收集类中所有类变量赋值动作和静态代码块中的语句合并来的

     如果该类有父类，jvm会保证父类的init()方法先执行，然后再执行子类的init()方法



###### 加载过程总结

当一个符合Java虚拟机规范的字节流文件，经历 加载、验证、准备、解析、初始化这些阶段相互协作执行完成之后，加载阶段读取到的Class字节流信息，会按虚拟机规定的格式，在方法区保存一份，然后Java 堆中，会创建一个 java.lang.Class 类的对象，这个对象描述了这个类所有信息，也提供了这个类在方法区的访问入口。

​	方法区中，使用同一加载器的情况下，每个类只会有一份Class字节流信息
​	Java堆中，使用同一加载器的情况下，每个类只会有一份 java.lang.Class 类的对象



###### 类加载器

![3065906840-5f9236c1b294a_fix732](C:\Users\ASUS\Desktop\3065906840-5f9236c1b294a_fix732.webp)

1. 启动类加载器

   启动类加载器是使用C/C++语言实现的，嵌套在JVM内部，java程序无法直接操作这个类

   负责加载JAVA_HOME/jre/lib 目录，或者被 -Xbootclasspath 参数制定的路径，例如 jre/lib/rt.jar 里所有的class文件，用于提供jvm运行所需的包

   不是java.lang.ClassLoader的子类，没有父类加载器

2. 扩展类加载器

   Java语言编写，可以用Java程序操作这个加载器

   负责加载Java平台中扩展功能的一些jar包，包括JAVA_HOME/lib/ext目录中或		java.ext.dirs指定目录下的jar包

   继承自java.lang.ClassLoader，父类加载器为启动器加载器

3. 应用程序加载器

   Java语言编写，继承自java.lang.ClassLoader，父类加载器为启动器加载器

### 7.64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马

### Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形不需要代码

1. 首先把64匹马随机分为8组并标记组别，遍历组别，比赛8次，并记录每组赛马名次(eg：A1>A2>...>A7>A8

​		首先可直接剔除各组后四名赛马，剩余64-4*8=32匹赛马待定

2. 选出每组排名第一的赛马进行一次比赛，记录结果，不失一般性地，记为：A1>B1>C1>D1>E1>F1>G1>H1

   根据这轮比赛结果，首先可以剔除E、F、G、H这四组所有赛马（因为本组第一都未进入前4），剩余16匹马

   其次可以确定A1就是全场MVP，属全场N01，剩余15匹马待定

   还可以进一步细化

   D组2-4名赛马：D2>D3>D4，不可能是Top4，可剔除这3匹，剩余15-3=12匹赛马待定

   C组3-4名赛马:C3>C4，不可能是Top4，可剔除这2匹，剩余12-2=10匹赛马待定

   B组第4名赛马：B4，也不可能是Top4，可剔除这1匹，剩余10-1=9匹赛马待定

3. 当前剩余待定9匹赛马：A2>A3>A4,B1>B2>B3,C1>C2,D1

   因为可以确定B1>C1>D1，因此挑选：A2>A3>A4,B1>B2>B3,C1>C2（ 或者 A2>A3>A4,B1>B2>B3,C1>D1）等8匹马进行一场比赛，剩余一匹赛马D1或者C2待定，重点关注C1名次

   **仅需1场比赛情形**

   当C1排名第3及以后，则选出本场前3名赛马，外加大佬A1，即为所求的Top4匹马

   **需2场比赛情形**

   因为已知B1>C1,所以C1本场名次区间为[2,8]

   当C1排名第2时，可推知B1排名本场第一，因此A1>B1>C1即为全场Top3匹马，此时可剔除B1,C1两匹马，剩余9-2=7匹马待定（如下）

   本轮上场剩余6匹：A2>A3>A4，B2>B3,C2

   未上场1匹：D1

   将本场剩余7匹赛马再进行一场比赛，一决高低，记录名次，选出本场排名第一的赛马，加上A1>B1>C1，即为全场Top4匹马。