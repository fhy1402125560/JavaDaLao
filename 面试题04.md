## 1.堆和栈的区别

​	在JVM中，栈使用的就是数据结构里的栈，先进后出，物理地址是连续的，所以性能快一些。而堆的物理地址分配对对象是不连续的，性能会慢一些。在GC的时候也会因为不连续的分配，使用了各种算法来GC，例如标记-消除、复制、标记-压缩、分代等

​	栈的内存大小在编译器就确认，大小是固定的。因为堆是不连续的，所以分配的内存是在运行期确定的大小不固定。一般堆的大小远远大于栈

​	栈存放 局部变量、操作数栈、返回结果，栈内存更关注的是程序方法的执行。堆中存放的是对象new出来的实例和数组。堆内存中关注的是数据的存储

​	栈只对于线程可见，也就是线程私有，生命周期和线程相同。堆对于整个应用程序都共享可见。

​	静态变量放在方法区，静态对象放在堆

## 2.JDK1.8的HashMap的hash函数做了什么优化

​	在JDK1.8中HashMap最大的优化就是将底层的数组+链表的结构换成了数组+链表+红黑树的结构。

​	JDK1.8中，在哈希碰撞发生时，默认还是将键值对存储在链表中，在超过阈值时，会将链表结构转化为红黑树(在节点少于阈值时还会将红黑树转化为链表),因为链表的增删效率高，查询效率低。红黑树增删效率低，查询效率高。当HashMap中存储的数据越来越多的时候，使用链表，查询效率就会很低。

​	在JDK1.8中，插入链表节点由头插法变成了尾插法，这样避免了并发下调用transfer()方法导致链表死循环，数据丢失的问题

​	在JDK1.8中，将hash值的高位(前16位)参与到取模运算中，让计算结果的不确定行增强，降低哈希碰撞发生的概率

​	在JDK1.8中，更改了扩容时数组元素下标的算法



## 3.MySQL B+树的结构，有什么好处

​	在MySQL中MyIsAM和InnoDB使用B+树作为索引。B+树的非叶子节点不存放数据，只存放索引，相比于即存放数据又存放索引的B树，B+树的非叶子节点可以存放更多的索引，所以B+树比B树更加的矮胖，磁盘的I/O次数会更少。B+树的数据都存储在叶子节点中，而且叶子节点之间使用了链表链接，方便扫库，只需要扫一遍叶子节点即可，而B树的非叶子节点也存放数据，在B树中查找数据需要对B树进行中序遍历，而B+树不用，所以B+树适合来完成范围查询。而大量的单个索引查询的场景适合用B树，像是nosql的mongodb中用B树作为索引。



## 4.redis为什么快

​	Redis是纯内存操作，数据存放在内存中，内存的读写速度要比磁盘快，Redis将数据持久化到磁盘来确保持久性，但大部分操作都在内存中执行。

​	Redis采用单线程，避免了多线程并发带来的锁和竞争产生的消耗

​	Redis提供了多种数据结构，在处理不同类型的数据时都能保持高效的性能

​	非阻塞I/O：Redis采用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为了时间，不在I/O上浪费过多时间

​	



## 5.redis的数据类型，平常用的是什么，

​	String，List，Set，Zset，Hash

## 6.treeSet和treeMap的区别

​	TreeSet是单列集合，TreeMap是双列集合，TreeSet底层是用TreeMap的key值实现的，像是TreeSet的add()方法，就是调用了TreeMap的put()方法进行添加。TreeSet和TreeMap底层都是用红黑树实现的，所以TreeSet和TreeMap的区别就是Set和Map的区别，也就是TreeSet用来存储唯一的数据并进行排序，TreeMap用来存储键值对，并根据键的排序进行操作。

## 7.@Autowired 和 @Resource 的区别是什么？

​	这两个注解都是在Java种用于依赖注入(DI)的注解，可用在 构造器、成员变量、Setter()方法上

@Autowired是Spring框架提供的注解，@Resource是JavaEE规范的一部分，也可以在非Spring的JavaEE容器中使用。

@Autowired默认是按照bean类型进行注入，如果有多个匹配的bean，通常会抛出异常，除非是用@Qualifier指定具体的bean名称或者使用@Primary指定主要的bean。	@Resource默认是按照bean名称进行注入，只有当找不到与名称匹配的bean才会按照类型进行注入，也可以通过name属性指定注入的bean的名称

