# 1.**接口和抽象类的区别，如何选择？** 

1. 抽象类中可以没有抽象方法；接口中的方法必须是抽象方法。
2. 抽象类中可以有普通的成员变量；接口中的变量必须是public static final类型的，必须被初始化，接口中只有常量，没有变量。
3. 抽象类只能单继承，**接口可以继承多个父接口**。



如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。
如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，**只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。**因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有背全部实现，该类就仍是抽象类。

# 2.**如何理解Java中的多态** 

多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。用白话来说，就是多个对象调用同一个方法，得到不同的结果。

多态就是把 做什么 和 怎么做分开了

降低耦合

# 3.**Java中有了基本类型为什么还需要包装类？** 

包装类中有基本数据类型没有的方法和属性，基本数据类型没有null值包装类有，集合类只能存储对象不能使用基本数据类型

# 4.**String、StringBuilder和StringBuffer的区别？** 

效率：String最慢，StringBuilder最快

线程安全：String、StringBuffer线程安全，StringBuilder线程不安全

安全原因：String底层是final修饰的不可变序列，放在常量池中，StringBuffer使用synchroized保证安全

适用情况：String少量字符串，StringBuilder单线程大量字符串，StringBuffer多线程大量字符串

# 5.**什么是泛型？有什么好处？** 

泛型是Java语法糖的一种，语法糖就是在计算机语言中添加一种语法，但是对程序本身执行没有影响，方便程序员使用，像是泛型、自动装箱拆箱、枚举、lambda表达式等都是语法糖

在Java中，泛型使用<>指定类型参数，泛型主要的目的就是增加代码的安全性和可读性，在编译阶段会把这些泛型类型擦除，编译为Object类型，

# 6.**Java中创建对象有哪些种方式** 

new

反射  Class类的newInstance()方法、Constructor类的newInstance()方法

clone()

反序列化ObjectInputStream的readObject()方法



# 7.基本数据类型 

int、short、byte、long、float、double、char、boolean

# 8.方法重写和重载的区别 

重写发生在类与类之间的继承或者是类接口的实现之间，子类可以对父类或者父接口的方法进行增强，在重写时，方法的形参列表、方法名是一致的，访问权限和抛出的异常类型是变大的，重写的时候通常在方法上使用@Override注解

重载是在同包桶类下，方法名相同的方法，他们的形参列表不同，方便调用方法的时候，可以根据不同的参数对方法进行调整

# 9.**创建线程有几种方式？** 

继承Thread类

Runnable  无返回值

Callable	有返回值

线程池

# 10.**什么是多线程中的上下文切换？** 

多线程上下文切换就是一个线程使用完CPU分给它的时间片之后，这个线程进入阻塞或是等待状态，且换到其他线程进入运行状态。也可能是一些操作让运行状态的线程进入等待或阻塞状态，切换其他线程

# 11.**什么是并发，什么是并行？** 

并发就是在用以时间段执行，微观上发生线程的上下文切换，只不过切换的很快，看起来像是同时运行的，单核CPU同时处理任务

并行就是一起执行，真正意义上的同时执行，多核CPU同时处理多个任务

# 12.**线程有几种状态，状态之间的流转是怎样的？** 

java中的是

NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。

RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。

BLOCKED：阻塞状态，需要等待锁释放。

WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。

TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。

TERMINATED：终止状态，表示该线程已经运行完毕。

# 13.**什么是守护线程，和普通线程有什么区别？** 

守护线程也被称为后台线程或者是服务线程，是为用户线程提供服务的，当其他线程执行结束后，不管守护线程执没执行完，都会随着用户线程的结束而结束

可以通过调用setDaemon()方法来设置守护线程

垃圾回收线程就是守护线程

# 14.**run/start、wait/sleep、notify/notifyAll区别?**

start用于启动线程，会创建一个新的线程调用run方法

run方法用于定义线程的执行逻辑，可以重写该方法实现自定义的线程行为



sleep是Thread类的方法，wait是Object类的方法

sleep是让调用线程进入阻塞状态，让出机会给其他线程，时间到了自动恢复运行状态，不会释放锁

wait会释放当前对象的锁，让对象进入等待状态，只有调用notify、notifyAll方法再回恢复



notify和notifyAll都是用来唤醒wait方法等待的对象的

notifyAll是唤醒所有等待对象，notify是随机唤醒一个

