# 1.什么是序列化与反序列化

序列化就是讲数据结构或Java对象转换为二进制字节流的形式

反序列化就是讲序列化过程生成的二进制字节流转换成数据结构或Java对象的形式

- 对象在进行**网络传输**（远程方法调用RPC的时候）之前需要先被序列化，接收到序列化对象之后再进行反序列化
- 将对象存储到**文件**之前需要进行序列化，将对象从文件中读取出来需要进行反序列化
- 将对象存储到**数据库**之前需要进行序列化，将对象从数据库中读取出来需要进行反序列化
- 将对象存储到**内存**之前需要进行序列化，将对象从内存中读取出来需要进行反序列化

序列化协议属于 TCP/IP 协议应用层的一部分

# 2.HashMap、Hashtable和ConcurrentHashMap的区别？

- **线程是否安全：**
  - HashMap是非线程安全的
  - Hashtable 中的方法是同步的，所以它是线程安全的。
  - ConcurrentHashMap在JDK 1.8之前使用分段锁保证线程安全，ConcurrentHashMap默认情况下将hash表分为16个桶(分片)，在加锁的时候，针对每个单独的分片进行加锁，其他分片不受影响。锁的粒度更细，所以他的性能更好。
    ConcurrentHashMap在JDK 1.8中，采用了-种新的方式来实现线程安全，即使用了CAS+synchronized，这实现被称为“分段锁”的变种，也被称为“锁分离”，它将锁定粒度更细，把锁的粒度从整个Map降低到了单个桶。
- **底层：**
  - HashMap底层是数组+链表(jdk1.7)数组+链表+红黑树(jdk1.8)	
  - HashTable底层是数组+链表     
  - ConcurrentHashMap底层分段数组+链表(jdk1.7) 数组+链表+红黑树(jdk1.8)
- **对Null key和Null value的支持：**
  - HashMap可以存null key和null value，但null key只能由一个   
  - HashTable不允许null key和null value    
  - ConcurrentHashMap不允许null key和null value
- **初始容量和每次扩容大小：**
  - HashMap的默认初始容量为16，默认的加载因子为0.75，即当HashMap中元素个数超过容量的75%时，会进行扩容操作。扩容时，容量会扩大为原来的两倍，并将原来的元素重新分配到新的桶中。
  - Hashtable，默认初始容量为11，默认的加载因子为0.75，即当Hashtable中元素个数超过容量的75%时，会进行扩容操作。扩容时，容量会扩大为原来的两倍加1，并将原来的元素重新分配到新的桶中。
  - ConcurrentHashMap，默认初始容量为16，默认的加载因子为0.75，即当ConcurrentHashMap中元素个数超过容量的75%时，会进行扩容操作。扩容时，容量会扩大为原来的两倍，并会采用分段锁机制，将ConcurrentHashMap分为多个段(segment)，每个段独立进行扩容操作，避免了整个ConcurrentHashMap的锁竞争。

# 3.为什么有了HTTP还要有RPC

纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 **消息边界** 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。

**RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。

从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。** 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。

RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。

**HTTP2.0** 在 **HTTP1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

# 4.volatile能保证原子性吗？什么能保证原子性？

**`volatile` 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。**

synchronized、ReentrantLock

# 5.垃圾回收算法CMS了解吗

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![CMS 收集器](E:\笔记\面试题\assets\cms-garbage-collector.png)主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

# 6.说一下RocketMQ 的事务消息如何来保证数据的最终一致性

上游服务会先发送一个 `half` 消息给 `RocketMQ`

`half` 消息发送成功，`RocketMQ` 收到这个 half 消息后，会返回一个 success 响应给`上游服务`。

`上游服务`接收到 `RocketMQ` 返回的 success 响应后，开始处理本地的业务逻辑，并提交本地事务。

如果`上游服务`本地事务提交成功，则会向`RocketMQ`中发送 commit，表示将 half 消息提交

如果`上游服务`本地事务提交失败，则直接回滚本地事务，并向`RocketMQ`中发送 rollback，表示将之前的 half 消息进行回滚，MQ 接收到 rollback 消息后，就会将 half 消息删除。

如果`RocketMQ`收到commit，就将消息写入磁盘

如果`RocketMQ`收到half，就丢弃消息

如果 `RocketMQ` 长时间没有接收到 commit 或者 rollback 消息，就会在一定时间后尝试调用上游服务提供的一个接口，通过这个接口来判断 half 消息的状态。



# 7.mysql什么情况下适合走索引，什么情况下不适合？

**不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。

**被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。

**被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。

**频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。

**被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率



**1.在where条件中（包括group by以及order by）里用不到的字段不需要创建索引**，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。

**2.数据量小的表最好不要使用索引**

如果表中记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化的效果。（了解：比如我们在一个表记录比较少的表上建立一个二级索引，那么查询的时候还需要经过索引，然后再进行回表那么这样消耗的时间可能比直接查询消耗的时间会更多）

**3.有大量重复数据的列上不要建立索引**

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表中的性别字段上只有男和女两个不同的值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。

索引的价值是帮你快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值，比如通常情况下的性别字段。

说明：当数据重复度大，比如高于10%的时候，也不需要对这个字段使用索引

**4.避免对经常更新的表创建过多的索引**

①频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候会造成负担，从而影响效率。

②避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新 表的速度。

**5.不建议使用无序的值作为索引**

例如身份证、uuid（在索引比较时需要转为ASCII，并且插入时可能会造成页分裂，这些了解即可）、md5、hash、无序字符串等。

**6.删除不再使用或者很少使用的索引**

表中的数据被大量更新或者数据的使用方式被改变后原有的一些索引可能不再需要。数据库管理员应该定期找出这些索引，将他们删除，从而减少索引对更新操作的影响。

**7.不要定义冗余或者重复的索引**