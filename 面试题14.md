# 1.TCP为什么要三次握手

在网络环境比较复杂的情况，客户端可能会连续发送多次请求。如果只设计成两次握手的情况，服务端只能一直接收请求，然后返回请求信息，也不知道客户端是否请求成功。这些过期请求的话就会造成网络连接的混乱。

所以设计成三次握手的情况，客户端在接收到服务端`SEQ+1`的返回消息之后，就会知道这个连接是历史连接，所以会发送报文给服务端，告诉服务端。

所以TCP设计成三次握手的目的就是为了**避免重复连接**。

# 2.redis常见类型

- **5 种基础数据类型**：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。
- **3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。

除了上面提到的之外，还有一些其他的比如 Bloom filter（布隆过滤器）open in new window、Bitfield（位域）。

# 3.gc机制



Eden-->survivor-->老年代

GC机制发生在堆内存中，Java堆=新生代+老年代，新生代=Eden+s0+s1

当Eden区的空间满了，Java虚拟机回触发一次MinorGC，回收新生代的垃圾，存活的对象回转移到Survivor区

**大对象**(需要大量连续内存空间的Java对象，如长字符串)，直接进入老年代

对象在Eden出生，经过一次MinorGC后存活，并被Survivor容纳，年龄设为1，没经过一次MinorGC，年龄+1，**年龄超过15 ，晋升至老年代**。**即长期存活的对象进入老年代**

老年代满了无法容纳更多的对象，MinorGC之后回进行FullGC，FullGC清理整个堆内存，包括新生代和老年代

MajorGC发生在老年代，清理老年区，比MinorGC慢10倍以上



新生代采用的是复制算法，因为新生代中每次都会回收大量对象，存活下来的较少。新生代一共被分成了三块，Eden和两个survivor，对象在Eden区出生，当进行回收时，讲Eden区和一块survivor区的存活的对象复制到另一块survivor

老年代回收少量对象，因此待用**标记整理法**(Mark-Compact)。

Serial 垃圾收集器（单线程、复制算法） 是java 虚拟机运行在Client 模式下默认的新生代垃圾收集器。

ParNew 垃圾收集器（Serial+多线程）是很多java虚拟机运行在Server 模式下新生代的默认垃圾收集器

Parallel Scavenge 收集器（多线程复制算法、高效） 重点关注的是程序达到一个可控制的吞吐量 。自适应调节策略也ParallelScavenge收集器与ParNew 收集器的一个重要区别

Serial Old 收集器（单线程标记整理算法） 运行在Client 默认的java 虚拟机默认的年老代垃圾收集器

Parallel Old 收集器（多线程标记整理算法）Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器

CMS 收集器（多线程标记清除算法）主要目标是获取最短垃圾回收停顿时间 CMS 收集器的内存回收和用户线程是一起并发地执行

G1 收集器 G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域,并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域

ZGC 收集器  CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进



# 4.讲一下mysql的事务

**要么全部执行成功,要么全部不执行**

**原子性**（`Atomicity`）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

**一致性**（`Consistency`）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

**隔离性**（`Isolation`）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

**持久性**（`Durability`）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的**

#### 脏读（Dirty read) 

#### 丢失修改（Lost to modify）

#### 不可重复读（Unrepeatable read)  

#### 幻读（Phantom read）

**READ-UNCOMMITTED(读取未提交)** ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

**READ-COMMITTED(读取已提交)** ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

**REPEATABLE-READ(可重复读)** ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

**SERIALIZABLE(可串行化)** ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

MySQL 中并发事务的控制方式无非就两种：**锁** 和 **MVCC**。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。

# 5..mysql索引原理和索引失效场景

`SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;

创建了组合索引，但查询条件未准守最左匹配原则;

在索引列上进行计算、函数、类型转换等操作;

以 % 开头的 LIKE 查询比如 `LIKE '%abc';`;

查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;

IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);

发生隐式转换open in new window



# 6.volatile是什么

在 Java 中，`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

`volatile` 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 `volatile` 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。

# 7.多线程使用场景，线程池，参数，拒绝策略

1、后台任务，例如：定时向大量（100w以上）的用户发送邮件； 2、异步处理，例如：发微博、记录日志等； 3、分布式计算



线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

**线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。**



**`ThreadPoolExecutor` 3 个最重要的参数：**

- **`corePoolSize` :** 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- **`maximumPoolSize` :** 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

`ThreadPoolExecutor`其他常见参数 :

- **`keepAliveTime`**:线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 `corePoolSize` ，回收过程才会停止。

- **`unit`** : `keepAliveTime` 参数的时间单位。

- **`threadFactory`** :executor 创建新线程的时候会用到。

- **`handler`** :饱和策略。

  

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，`ThreadPoolTaskExecutor` 定义一些策略:

- **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。

# 8.锁，乐观锁，悲观锁，独占锁，共享锁

**乐观锁**：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。

**悲观锁**：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。

**独占锁**：一把锁只能被一个线程获得。

**共享锁**：一把锁可以被多个线程同时获得。

# 9.ArrayList是怎么实现序列化的

`ArrayList`在Java中实现序列化主要依赖于Java的序列化机制。我们知道，在Java中，只需要实现`java.io.Serializable`接口的类就可以被序列化。



`ArrayList`就是这样一个实现了`Serializable`接口的类，所以它可以被序列化。序列化过程中，`ArrayList`的非`transient`(临时性的)字段（包括用于存储元素的数组，以及记录ArrayList大小的`size`字段）都会被序列化。



但是`ArrayList`的实现代码中，还有一个自定义的序列化过程。这个过程是在`writeObject`方法中定义的。这个方法在序列化`ArrayList`时，首先写入`ArrayList`的“容量”（也就是数组的大小），然后再将每一个元素都写入到输出流。这就是`ArrayList`为什么可以被序列化，而且可以正确地恢复其所有元素的原因。



在反序列化过程中，同理，也有一个自定义的反序列化过程，就是在`readObject`方法中定义的。这个方法会首先读取`ArrayList`的“容量”，然后实例化一个足够大的数组，并将数组的每一个元素都从输入流中读取出来。



总的来说，`ArrayList`的序列化和反序列化是通过实现`Serializable`接口，并定义了自己的`writeObject`和`readObject`方法来完成的。通过这种方式，基于`ArrayList`的序列化可以确保元素的顺序和内容在反序列化后能被准确地恢复。



# 深拷贝和浅拷贝

1. 浅拷贝：仅创建一个新对象，并复制原始对象的引用类型的引用以及基础类型的值。当复制引用类型时，不会为被引用到的对象创建新的副本。这导致新的对象和原始对象可能共享一些相同的字段或内部状态，如果更改其中一个对象，可能会影响另一个对象。
2. 深拷贝：创建一个新对象，并复制原始对象的引用类型的"值"以及基础类型的值。当复制引用类型时，会为被引用到的对象创建新的副本。这意味着新对象不会与原始对象共享任何字段或内部状态，两个对象可以独立地变化，互不影响。

